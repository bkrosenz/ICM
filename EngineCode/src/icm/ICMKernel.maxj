/**
 * Document: MaxCompiler Training (maxcompiler-training.pdf)
 * Chapter: 2
 * Exercise Solution: 3
 * Summary:
 * 	 Kernel that performs a 7x7 Gaussian blur to remove minor detail
 *   in the image then performs 3x3 Sobel edge detection.
 *   The Sobel coefficients are declared statically in a 3x3 array.
 *   The Gaussian coefficients are stored in 7-element 1D array and
 *   are applied in one dimension, then the other.
 *   At the border of the image, the output is set to 0 . The 3-pixel
 *   boundary condition of the Gaussian blur is not taken into account
 *   for simplicity.
 */
package icm;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;

class ICMKernel extends Kernel {

   private final double beta = 1.5; // interaction parameter
    private final double invVar = 5.0; // 1/(2*variance) of gaussian noise, since div is more costly than mult
    private final int nColors = 2;
    static final DFEType floatType = dfeFloat(8, 24);
    static final DFEType intType = dfeUInt(32);
  
	protected ICMKernel(KernelParameters parameters) {
		super(parameters);

		int height = 256, width = 256;

		DFEVar inImage = io.input("inImage", dfeInt(32));

        int i;
         
                /* Memory<DFEVar> priors = mem.alloc(intType, nColors);
//        priors.mapToCPU("priors");
//        DFEVar sqrt = priors.read(inImage.cast(dfeUInt(8)));

        int step = 256 / nColors; // assume java ints are the same size as those in the ppm
        double contents[] = new double[nColors];
		for (int i = 0; i < nColors; i++)
			contents[i] = i*step;
        priors.setContents(contents);
           
          TODO: handle edge and corner pixels.
		TODO: use more than 2 colors, find better way to index into colorCounts.  
		can't modify vectors at runtime - need a state machine?
		fastram, or regular (very slow) ram?
		 
		DFEVectorType<DFEVar> vectorType = new DFEVectorType<DFEVar>(intType, nColors); // precision must be at least height*width 
        DFEVector<DFEVar> colorCounts = vectorType.newInstance(this);
        
         DFEVar zero = constant.var(intType,0);
        for (i=0; i<nColors; ++i)
            colorCounts[i] <== zero;
            
		for (i = 1; i < 4; i++) {
		    for (int c = 0; c < nColors; ++c){
    		    colorCounts[c] <== stream.offset(inImage, i) === c ? colorCounts[c] + 1 : colorCounts[c];
    		    colorCounts[c] <== stream.offset(inImage, -i) === c ? colorCounts[c] + 1 : colorCounts[c];
    		    colorCounts[c] <== stream.offset(inImage, i * width) === c ? colorCounts[c] + 1 : colorCounts[c];
    		    colorCounts[c] <== stream.offset(inImage, -i * width) === c ? colorCounts[c] + 1 : colorCounts[c];
		    }
		}

        DFEVar posterior_max = constant.var(0.0);
		for (i = 0; i < nColors; ++i){
		     DFEVar residual = inImage-i*step; // TODO: change i to something like priors.read(i);
             posterior = residual * residual * invVar - b * colorCounts[i];
             result = (posterior > posterior_max) ? i : result;
             posterior_max = (posterior > posterior_max) ? posterior : posterior_max;
        }
        */		  
		// count neighbors
		DFEVar black = constant.var(0);
		for (i = 1; i < 4; i++) {
    		    black = (stream.offset(inImage, i) < 128 ) ? black+1 : black;
    		    black = (stream.offset(inImage, -i) < 128 ) ?  black+1 : black;
    		    black = (stream.offset(inImage, i * width) < 128 ) ?  black+1 : black;
    		    black = (stream.offset(inImage, - i * width) < 128 ) ?  black+1 : black;
		    }
		    
		 
		DFEVar result = constant.var(dfeInt(32),0); // argmax_i

        DFEVar residual = inImage; // TODO: change to inImage-i*step, or replace iw with something like priors.read(i);
         DFEVar post_black = residual * residual * invVar - b * black;
         DFEVar post_white = residual * (256-residual) * invVar - b * (8-black); // 8 is neighborhood size
        result = (post_black > post_white) ? constant.var(0) : constant.var(255);

		io.output("outImage", result, result.getType());
	}
}
