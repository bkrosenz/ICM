/**
 * Document: MaxCompiler Training (maxcompiler-training.pdf)
 * Chapter: 2
 * Exercise Solution: 3
 * Summary:
 * 	 Kernel that performs a 7x7 Gaussian blur to remove minor detail
 *   in the image then performs 3x3 Sobel edge detection.
 *   The Sobel coefficients are declared statically in a 3x3 array.
 *   The Gaussian coefficients are stored in 7-element 1D array and
 *   are applied in one dimension, then the other.
 *   At the border of the image, the output is set to 0 . The 3-pixel
 *   boundary condition of the Gaussian blur is not taken into account
 *   for simplicity.
 */
package icm;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;

class ICMKernel extends Kernel {

    private final double beta = 1.5; // interaction parameter
    private final double invVar = 5.0; // 1/(2*variance) of gaussian noise, since div is more costly than mult
    private final int nColors = 2;
    static final DFEType floatType = dfeFloat(8, 24);
    static final DFEType intType = dfeUInt(32);

    protected ICMKernel(KernelParameters parameters) {
	super(parameters);

	int height = 256, width = 256;

	DFEVar inImage = io.input("inImage", dfeInt(32));

	int i;

/* Memory<DFEVar> priors = mem.alloc(intType, nColors);
//        priors.mapToCPU("priors");
//        DFEVar sqrt = priors.read(inImage.cast(dfeUInt(8)));

int step = 256 / nColors; // assume java ints are the same size as those in the ppm
double contents[] = new double[nColors];
for (int i = 0; i < nColors; i++)
contents[i] = i*step;
priors.setContents(contents);

TODO: handle edge and corner pixels.
TODO: use more than 2 colors, find better way to index into colorCounts.  
can't modify vectors at runtime - need a state machine?
fastram, or regular (very slow) ram?

DFEVectorType<DFEVar> vectorType = new DFEVectorType<DFEVar>(intType, nColors); // precision must be at least height*width 
DFEVector<DFEVar> colorCounts = vectorType.newInstance(this);

DFEVar zero = constant.var(intType,0);
for (i=0; i<nColors; ++i)
colorCounts[i] <== zero;

for (i = 1; i < 4; i++) {
for (int c = 0; c < nColors; ++c){
colorCounts[c] <== stream.offset(inImage, i) === c ? colorCounts[c] + 1 : colorCounts[c];
colorCounts[c] <== stream.offset(inImage, -i) === c ? colorCounts[c] + 1 : colorCounts[c];
colorCounts[c] <== stream.offset(inImage, i * width) === c ? colorCounts[c] + 1 : colorCounts[c];
colorCounts[c] <== stream.offset(inImage, -i * width) === c ? colorCounts[c] + 1 : colorCounts[c];
}
}

DFEVar posterior_max = constant.var(0.0);
for (i = 0; i < nColors; ++i){
DFEVar residual = inImage-i*step; // TODO: change i to something like priors.read(i);
posterior = residual * residual * invVar - b * colorCounts[i];
result = (posterior > posterior_max) ? i : result;
posterior_max = (posterior > posterior_max) ? posterior : posterior_max;
}
*/

	/********** 
// count neighbors
	DFEVar black = constant.var(0);
	for (i = 1; i < 4; i++) {
	    black = (stream.offset(inImage, i) < 128 ) ? black+1 : black;
	    black = (stream.offset(inImage, -i) < 128 ) ?  black+1 : black;
	    black = (stream.offset(inImage, i * width) < 128 ) ?  black+1 : black;
	    black = (stream.offset(inImage, - i * width) < 128 ) ?  black+1 : black;
	}


	DFEVar result = constant.var(dfeInt(32),0); // argmax_i

	DFEVar residual = inImage; // TODO: change to inImage-i*step, or replace iw with something like priors.read(i);
// posteriors:
	DFEVar post_black = residual * residual * invVar - beta * black;
	DFEVar post_white = residual * (256-residual) * invVar - beta * (8-black); // 8 is neighborhood size
	result = (post_black > post_white) ? constant.var(0) : constant.var(255);

	io.output("outImage", result, result.getType());
	**********\


		int height = 256, width = 256;

		DFEVar inImage = io.input("inImage", dfeInt(32));

		int[] GaussianCoeffs = { 6, 61, 242, 383, 242, 61, 6 };

		DFEVar GaussianX = constant.var(0);

		/*
		 * Unoptimized:
		 * for (int x=-3; x<4; x++)
		 * GaussianX = GaussianX +
		 * 		(stream.offset(inImage, x) * GaussianCoeffs[x+3] / 1000);
		 */

		for (int x = 1; x < 4; x++) {
			DFEVar preAdd = constant.var(0);
			preAdd = preAdd + stream.offset(inImage, x);
			preAdd = preAdd + stream.offset(inImage, -x);
			GaussianX = GaussianX + (preAdd * GaussianCoeffs[x + 3] / 1000);
		}
		GaussianX = GaussianX + (inImage * GaussianCoeffs[3] / 1000);

		DFEVar GaussianY = constant.var(0);

		/*
		 * Unoptimized:
		 * for (int y=-3; y<4; y++)
		 * 	GaussianY = GaussianY +
		 * 		(stream.offset(GaussianX, y*width) * GaussianCoeffs[y+3] / 1000);
		 */

		for (int y = 1; y < 4; y++) {
			DFEVar preAdd = constant.var(0);
			preAdd = preAdd + stream.offset(GaussianX, y * width);
			preAdd = preAdd + stream.offset(GaussianX, -y * width);
			GaussianY = GaussianY + (preAdd * GaussianCoeffs[y + 3] / 1000);
		}

		GaussianY = GaussianY + (GaussianX * GaussianCoeffs[3] / 1000);

		int[][] Gx = { { -1, 0, 1 }, // y, x
				       { -2, 0, 2 },
				       { -1, 0, 1 } };
		int[][] Gy = { { 1, 2, 1 }, // y, x
				       { 0, 0, 0 },
				       { -1, -2, -1 } };

		DFEVar window[][] = new DFEVar[3][3]; // x, y

		for (int x = -1; x <= 1; x++)
			for (int y = -1; y <= 1; y++)
				window[x + 1][y + 1] = stream.offset(GaussianY, y * width + x);

		DFEVar GxSum = constant.var(0);
		DFEVar GySum = constant.var(0);

		for (int x = 0; x < 3; x++) {
			for (int y = 0; y < 3; y++) {
				GxSum = GxSum + window[x][y] * Gx[y][x];
				GySum = GySum + window[x][y] * Gy[y][x];
			}
		}

		DFEVar absGxSum = GxSum >= 0 ? GxSum : -GxSum;
		DFEVar absGySum = GySum >= 0 ? GySum : -GySum;

		DFEVar result = absGxSum + absGySum;
    }
}
